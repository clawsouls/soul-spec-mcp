#!/usr/bin/env node

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

const API_BASE = "https://clawsouls.ai/api/v1";
const SOULS_DIR_DEFAULT = "~/.openclaw/souls";

// --- API helpers ---

async function apiGet(path: string): Promise<unknown> {
  const res = await fetch(`${API_BASE}${path}`);
  if (!res.ok) throw new Error(`API error ${res.status}: ${await res.text()}`);
  return res.json();
}

async function apiFetch(url: string): Promise<Response> {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Fetch error ${res.status}`);
  return res;
}

// --- Soul Spec file conversion ---

const SECTION_MAP: Record<string, string> = {
  "SOUL.md": "Persona",
  "IDENTITY.md": "Identity",
  "STYLE.md": "Communication Style",
  "AGENTS.md": "Workflow",
  "HEARTBEAT.md": "Periodic Checks",
};

function filesToClaudeMd(
  files: Record<string, string>,
  meta: { displayName?: string; name?: string; version?: string; description?: string }
): string {
  const sections: string[] = [];
  const name = meta.displayName || meta.name || "AI Agent";
  const ver = meta.version ? ` v${meta.version}` : "";

  sections.push(`# ${name}${ver}`);
  if (meta.description) sections.push(`> ${meta.description}`);
  sections.push("");
  sections.push("<!-- Generated by Soul Spec MCP (soul-spec-mcp) -->");
  sections.push("<!-- Source: https://clawsouls.ai -->");
  sections.push("");

  for (const [filename, sectionTitle] of Object.entries(SECTION_MAP)) {
    const content = files[filename];
    if (content) {
      sections.push(`## ${sectionTitle}\n\n${content}\n`);
    }
  }

  return sections.join("\n").trimEnd() + "\n";
}

// --- Server setup ---

const server = new McpServer({
  name: "soul-spec-mcp",
  version: "0.1.0",
});

// Tool: search_souls
server.tool(
  "search_souls",
  "Search AI agent personas on ClawSouls registry by keyword, category, or tag",
  {
    query: z.string().optional().describe("Search keyword"),
    category: z.string().optional().describe("Category filter (e.g., 'work/engineering', 'creative')"),
    tag: z.string().optional().describe("Tag filter"),
    limit: z.number().optional().default(100).describe("Max results (default 100)"),
  },
  { title: "Search Personas", readOnlyHint: true, openWorldHint: false },
  async ({ query, category, tag, limit }) => {
    const params = new URLSearchParams();
    if (query) params.set("q", query);
    if (category) params.set("category", category);
    if (tag) params.set("tag", tag);
    if (limit) params.set("limit", String(limit));

    const data = await apiGet(`/souls?${params.toString()}`) as {
      souls: Array<{
        owner: string; name: string; displayName: string;
        description: string; category: string; tags: string[];
        downloads: number; avgRating: number;
      }>;
    };

    if (!data.souls?.length) {
      return { content: [{ type: "text" as const, text: "No souls found matching your search." }] };
    }

    const lines = data.souls.map((s, i) =>
      `${i + 1}. **${s.displayName}** (\`${s.owner}/${s.name}\`)\n   ${s.description}\n   Category: ${s.category} | ⬇️ ${s.downloads} | ⭐ ${s.avgRating?.toFixed(1) || "N/A"}`
    );

    return {
      content: [{
        type: "text" as const,
        text: `Found ${data.souls.length} soul(s):\n\n${lines.join("\n\n")}\n\nUse \`get_soul\` for details or \`install_soul\` to download.`,
      }],
    };
  }
);

// Tool: get_soul
server.tool(
  "get_soul",
  "Get detailed information about a specific soul on ClawSouls",
  {
    owner: z.string().describe("Soul owner (e.g., 'TomLeeLive')"),
    name: z.string().describe("Soul name (e.g., 'brad')"),
  },
  { title: "Get Persona Details", readOnlyHint: true, openWorldHint: false },
  async ({ owner, name }) => {
    const s = await apiGet(`/souls/${owner}/${name}`) as {
      displayName: string; description: string; category: string;
      tags: string[]; version: string; license: string;
      downloads: number; avgRating: number; reviewCount: number;
      files: Record<string, string>;
      scanScore?: number; scanGrade?: string;
    };

    const fileList = Object.values(s.files || {}).join(", ");

    const text = [
      `# ${s.displayName} (${owner}/${name})`,
      `> ${s.description}`,
      "",
      `- **Version**: ${s.version}`,
      `- **Category**: ${s.category}`,
      `- **Tags**: ${s.tags?.join(", ") || "none"}`,
      `- **License**: ${s.license}`,
      `- **Downloads**: ${s.downloads}`,
      `- **Rating**: ${s.avgRating?.toFixed(1) || "N/A"} (${s.reviewCount} reviews)`,
      s.scanScore != null ? `- **SoulScan**: ${s.scanScore}/100 (${s.scanGrade})` : "",
      `- **Files**: ${fileList}`,
      "",
      `Use \`install_soul\` to download and convert to CLAUDE.md.`,
    ].filter(Boolean).join("\n");

    return { content: [{ type: "text" as const, text }] };
  }
);

// Tool: install_soul
server.tool(
  "install_soul",
  "Download a soul from ClawSouls and generate a CLAUDE.md file for use with Claude Code/Cowork",
  {
    owner: z.string().describe("Soul owner (e.g., 'TomLeeLive')"),
    name: z.string().describe("Soul name (e.g., 'brad')"),
    output_dir: z.string().optional().describe("Directory to write CLAUDE.md (default: current directory)"),
  },
  { title: "Install Persona", readOnlyHint: false },
  async ({ owner, name, output_dir }) => {
    // Fetch bundle (includes file contents)
    const bundle = await apiGet(`/bundle/${owner}/${name}`) as {
      manifest: { displayName: string; name: string; description: string; version: string };
      files: Record<string, string>;
    };

    if (!bundle.files || Object.keys(bundle.files).length === 0) {
      return { content: [{ type: "text" as const, text: `Error: Soul "${owner}/${name}" has no files.` }] };
    }

    const claudeMd = filesToClaudeMd(bundle.files, bundle.manifest);

    const m = bundle.manifest;

    // Try to write file, fall back to returning content
    let writtenPath: string | null = null;
    try {
      const { writeFileSync, mkdirSync, existsSync } = await import("fs");
      const { resolve } = await import("path");
      const dir = output_dir || ".";
      const resolvedDir = resolve(dir);
      if (!existsSync(resolvedDir)) mkdirSync(resolvedDir, { recursive: true });
      writtenPath = resolve(`${dir}/CLAUDE.md`);
      writeFileSync(writtenPath, claudeMd, "utf-8");
    } catch {
      writtenPath = null;
    }

    if (writtenPath) {
      return {
        content: [{
          type: "text" as const,
          text: [
            `✅ Installed **${m.displayName}** (${owner}/${name} v${m.version})`,
            "",
            `CLAUDE.md written to: \`${writtenPath}\``,
            "",
            "Claude will automatically read this file as project instructions.",
            "",
            `Files included: ${Object.keys(bundle.files).join(", ")}`,
          ].join("\n"),
        }],
      };
    }

    // Fallback: return content for Claude to save via its own tools
    return {
      content: [{
        type: "text" as const,
        text: [
          `✅ Downloaded **${m.displayName}** (${owner}/${name} v${m.version})`,
          "",
          "I couldn't write the file directly. Please save the following as `CLAUDE.md` in your desired location:",
          "",
          "```markdown",
          claudeMd,
          "```",
          "",
          `Files included: ${Object.keys(bundle.files).join(", ")}`,
        ].join("\n"),
      }],
    };
  }
);

// Tool: list_categories
server.tool(
  "list_categories",
  "List available soul categories on ClawSouls",
  {},
  { title: "List Categories", readOnlyHint: true, openWorldHint: false },
  async () => {
    const categories = [
      "work/engineering — Software development, DevOps, architecture",
      "work/business — Business analysis, project management",
      "work/writing — Technical writing, copywriting, editing",
      "creative — Art, music, storytelling, worldbuilding",
      "education — Tutoring, mentoring, learning",
      "productivity — Task management, automation, organization",
      "social — Communication, community, support",
      "gaming — Game design, NPCs, game masters",
      "research — Academic, scientific, data analysis",
      "other — Everything else",
    ];

    return {
      content: [{
        type: "text" as const,
        text: `## Soul Categories\n\n${categories.map(c => `- **${c.split(" — ")[0]}** — ${c.split(" — ")[1]}`).join("\n")}\n\nUse \`search_souls\` with a category to browse.`,
      }],
    };
  }
);

// Tool: preview_soul
server.tool(
  "preview_soul",
  "Preview what a soul's CLAUDE.md would look like without installing",
  {
    owner: z.string().describe("Soul owner"),
    name: z.string().describe("Soul name"),
  },
  { title: "Preview Persona", readOnlyHint: true, openWorldHint: false },
  async ({ owner, name }) => {
    const bundle = await apiGet(`/bundle/${owner}/${name}`) as {
      manifest: { displayName: string; name: string; description: string; version: string };
      files: Record<string, string>;
    };

    if (!bundle.files || Object.keys(bundle.files).length === 0) {
      return { content: [{ type: "text" as const, text: `No files found for "${owner}/${name}".` }] };
    }

    const claudeMd = filesToClaudeMd(bundle.files, bundle.manifest);

    return {
      content: [{
        type: "text" as const,
        text: `## Preview: CLAUDE.md for ${bundle.manifest.displayName}\n\n\`\`\`markdown\n${claudeMd}\`\`\`\n\nUse \`install_soul\` to save this as CLAUDE.md.`,
      }],
    };
  }
);

// Tool: apply_persona
server.tool(
  "apply_persona",
  "Apply an AI persona to the current conversation immediately — no file saving needed",
  {
    owner: z.string().describe("Soul owner (e.g., 'TomLeeLive')"),
    name: z.string().describe("Soul name (e.g., 'brad')"),
  },
  { title: "Apply Persona", readOnlyHint: true, openWorldHint: false },
  async ({ owner, name }) => {
    const bundle = await apiGet(`/bundle/${owner}/${name}`) as {
      manifest: { displayName: string; name: string; description: string; version: string };
      files: Record<string, string>;
    };

    if (!bundle.files || Object.keys(bundle.files).length === 0) {
      return { content: [{ type: "text" as const, text: `No files found for "${owner}/${name}".` }] };
    }

    const m = bundle.manifest;
    const parts: string[] = [];

    parts.push(`# Persona: ${m.displayName} v${m.version}`);
    parts.push(`> ${m.description}`);
    parts.push("");
    parts.push("**From this point forward, adopt the following persona completely.** Maintain this identity, tone, and behavior for the rest of this conversation unless told otherwise.");
    parts.push("");

    // Include all soul files as instructions
    for (const [filename, content] of Object.entries(bundle.files)) {
      if (filename.endsWith(".md") && filename !== "LICENSE") {
        parts.push(`---`);
        parts.push(`### ${filename}`);
        parts.push(content);
        parts.push("");
      }
    }

    parts.push("---");
    parts.push(`✅ Persona **${m.displayName}** is now active. To save it permanently, use \`install_soul\` to generate a CLAUDE.md file.`);

    return {
      content: [{
        type: "text" as const,
        text: parts.join("\n"),
      }],
    };
  }
);

// --- Start server ---

async function main() {
  const args = process.argv.slice(2);
  const useHttp = args.includes("--http") || args.includes("--transport=http");
  const portIdx = args.indexOf("--port");
  const port = portIdx !== -1 ? parseInt(args[portIdx + 1], 10) : 3100;

  if (useHttp) {
    const { StreamableHTTPServerTransport } = await import(
      "@modelcontextprotocol/sdk/server/streamableHttp.js"
    );
    const { createServer } = await import("node:http");
    const { randomUUID } = await import("node:crypto");

    const httpTransport = new StreamableHTTPServerTransport({
      sessionIdGenerator: () => randomUUID(),
    });

    await server.connect(httpTransport);

    const httpServer = createServer(async (req, res) => {
      const url = new URL(req.url || "/", `http://localhost:${port}`);

      // Only handle /mcp endpoint
      if (url.pathname === "/mcp") {
        await httpTransport.handleRequest(req, res);
        return;
      }

      // Health check
      if (url.pathname === "/health") {
        res.writeHead(200, { "Content-Type": "application/json" });
        res.end(JSON.stringify({ status: "ok", transport: "streamable-http" }));
        return;
      }

      res.writeHead(404);
      res.end("Not Found");
    });

    httpServer.listen(port, () => {
      console.error(`soul-spec-mcp HTTP server listening on http://localhost:${port}/mcp`);
    });
  } else {
    const transport = new StdioServerTransport();
    await server.connect(transport);
  }
}

main().catch((error) => {
  console.error("Fatal error:", error);
  process.exit(1);
});
